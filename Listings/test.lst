C51 COMPILER V9.60.0.0   TEST                                                              03/20/2023 21:07:26 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE TEST
OBJECT MODULE PLACED IN .\Objects\test.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE test.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\others) DEBUG OBJECTEXTEND PRIN
                    -T(.\Listings\test.lst) TABS(2) OBJECT(.\Objects\test.obj)

line level    source

   1          #include "test.h"
   2          
   3          /* led pwm测试，前四个灯会累加计数，后四个灯会运行跑马灯，所有灯均会呈现呼吸灯的特效 */
   4          void led_pwm_test(void)
   5          {
   6   1        /* 这个数组保存了流水灯的每一帧的LED状态，仅后四个灯 */
   7   1        uint8_t code led_state_all[6] = 
   8   1        { 0x80, 0x40, 0x20, 0x10, 0x20, 0x40, };
   9   1        
  10   1        int16_t add = 1; //用于控制累加的方向
  11   1        uint8_t cnt = 0; //计数，并显示在前四个灯上
  12   1        uint8_t led_state_cnt = 0; //用于流水灯
  13   1          
  14   1        while(1)
  15   1        {
  16   2          if (Timer1s_cnt >= 1000)
  17   2          {
  18   3            Timer1s_cnt = 0;
  19   3            
  20   3            cnt++;
  21   3            
  22   3            if (++led_state_cnt >= 6) //用于流水灯
  23   3              led_state_cnt = 0;
  24   3          }
  25   2          
  26   2          if (Timer10ms_cnt >= 10) //10ms更新一次pwm占空比和led输出状态
  27   2          {
  28   3            Timer10ms_cnt = 0;
  29   3            
  30   3            /* 流水的控制 */
  31   3            led_pwm_duty += add;
  32   3            if (led_pwm_duty >= 100)
  33   3              add = -1;
  34   3            if (led_pwm_duty == 0)
  35   3              add = 1;
  36   3          
  37   3            led_state = (cnt & 0x0F) | led_state_all[led_state_cnt];
  38   3          }
  39   2        }
  40   1      }
  41          
  42          /* 按键测试 */
  43          void key_test(void)
  44          {
  45   1        uint8_t cnt = 127;
  46   1        
  47   1        while(1)
  48   1        {
  49   2          /* 10ms执行一次按键扫描 */
  50   2          if (Timer10ms_cnt >= 10) //这里可以修改消抖时间，如果想看清楚数码管和LED一闪而过的内容，不妨把这个值增大
             -到50或者更大，但是要记得调回来哦
  51   2          {
  52   3            Timer10ms_cnt = 0;
  53   3            
C51 COMPILER V9.60.0.0   TEST                                                              03/20/2023 21:07:26 PAGE 2   

  54   3            /* 按键扫描 */
  55   3      //      key_scan_simple();              /* 新手简单版 独立按键 */
  56   3      //      key_pad_scan_simple();          /* 新手简单版 矩阵按键 */
  57   3      //      key_scan_release();             /* 松手检测版 独立按键 */
  58   3            key_pad_scan_release();         /* 松手检测版 矩阵按键 */
  59   3      //      key_pad_half_scan_simple();     /* 串口冲突减半简单版 矩阵按键 */
  60   3      //      key_pad_remain_scan_simple();   /* 串口三五双双冲突残缺简单版 矩阵按键 */
  61   3            
  62   3            /* 判断按键 */
  63   3            /* 无非就是利用key_value和key_state两个变量来判断 */
  64   3            if (key_value == 4) //如果s4按下
  65   3            {
  66   4              switch (key_state)
  67   4              {
  68   5                case 2: //短按
  69   5                  led_state |= 0x02; //短按标志（一闪而过）
  70   5                break;
  71   5                
  72   5                case 100: //长按1s
  73   5                  led_state |= 0x04; //长按1s标志（一闪而过）
  74   5                break;
  75   5                
  76   5                case 200: //长按2s
  77   5                  led_state |= 0x08; //长按2s标志（一闪而过）
  78   5                break;
  79   5                
  80   5                case 255: //短按松手（一闪而过）
  81   5                  led_state |= 0x10; //松手标志
  82   5                break;
  83   5                
  84   5                case 254: //长按1s后松手（一闪而过）
  85   5                  led_state |= 0x20; //松手标志
  86   5                break;
  87   5                
  88   5                case 253: //长按2s后松手（一闪而过）
  89   5                  led_state |= 0x40; //松手标志
  90   5                break;
  91   5                
  92   5                default:
  93   5                  led_state &= ~0x7E; //其他时刻把led熄灭
  94   5              }
  95   4              
  96   4              led_state |= 0x01; //按下标志（按下持续点亮）
  97   4            }
  98   3            else //s4松开
  99   3            {
 100   4              led_state &= ~0xFF; //清除所有标志
 101   4              
 102   4              if (key_value == 7 && key_state == 2) //s7短按
 103   4                cnt++;
 104   4              if (key_value == 6 && key_state == 2) //s6短按
 105   4                cnt--;
 106   4            }
 107   3            
 108   3            /* 数码管显示 */
 109   3            {
 110   4              /* 键值显示 */
 111   4              dig[0] = key_value / 10;
 112   4              dig[1] = key_value % 10;
 113   4              
 114   4              /* 状态显示 */
 115   4              dig[3] = key_state / 100;
C51 COMPILER V9.60.0.0   TEST                                                              03/20/2023 21:07:26 PAGE 3   

 116   4              dig[4] = key_state / 10 % 10;
 117   4              dig[5] = key_state % 10;
 118   4              
 119   4              /* 可控变量显示 */
 120   4              dig[7] = cnt % 10;
 121   4            }
 122   3          }
 123   2        }
 124   1      }
 125          
 126          /* 显示测试 */
 127          void display_test(void)
 128          {
 129   1        uint8_t screen = 2; //当前界面
 130   1        uint8_t screen_bak = screen; //备份当前界面，以便重新返回
 131   1        uint8_t operate_num = 0; //用于错开两种长时读写的时机
 132   1        
 133   1        dig = dig_all[screen]; //默认为界面2
 134   1        
 135   1        //这里可以加上时钟初值的设置，也可以在ds1302.c里设置
 136   1        write_time(); //时钟初始化
 137   1        dac_level = 20;
 138   1        write_dac();
 139   1        
 140   1        while(1)
 141   1        {
 142   2          /* 10ms执行一次按键扫描 */
 143   2          if (Timer10ms_cnt >= 10)
 144   2          {
 145   3            Timer10ms_cnt = 0;
 146   3            
 147   3            /* 按键扫描 */
 148   3            key_pad_remain_scan_simple();
 149   3            
 150   3            if (Timer50ms_cnt >= 50)
 151   3            {
 152   4              Timer50ms_cnt = 0;
 153   4              
 154   4              switch (operate_num)
 155   4              {
 156   5                case 1:
 157   5                  read_time(); //读取时间
 158   5                  break;
 159   5                
 160   5                case 2:
 161   5                  read_adc(); //读取ADC
 162   5                  break;
 163   5                
 164   5                case 3:
 165   5                  break;
 166   5                
 167   5                case 4:
 168   5                  break;
 169   5                
 170   5                default:
 171   5                  operate_num = 0;
 172   5                  break;
 173   5              }
 174   4              operate_num++;
 175   4            }
 176   3            
 177   3            /* 判断按键 */
C51 COMPILER V9.60.0.0   TEST                                                              03/20/2023 21:07:26 PAGE 4   

 178   3            if (key_value == 4 && key_state > 2) //如果处于s4被按下期间
 179   3            {
 180   4              if (screen != 1) //你可以尝试注释掉这个判断语句看看功能会发送什么变化
 181   4              {
 182   5                screen_bak = screen; //备份当前界面号
 183   5                screen = 1; //显示界面1
 184   5              }
 185   4            }
 186   3            else
 187   3            {
 188   4              if (screen == 1) //你可以尝试注释掉这个判断语句看看功能会发送什么变化
 189   4              {
 190   5                screen = screen_bak; //还原因s4改变的界面
 191   5              }
 192   4            }
 193   3            
 194   3            if (key_value == 5 && key_state == 100) //如果s5长按1秒
 195   3            {
 196   4              if (screen) //关闭
 197   4              {
 198   5                screen_bak = screen; //备份当前界面号
 199   5                screen = 0; //关闭显示（黑屏界面）
 200   5                stop_dac(); //停止DAC输出
 201   5              }
 202   4              else //开启
 203   4              {
 204   5                screen = screen_bak; //还原显示
 205   5                write_dac(); //重启DAC输出
 206   5              }
 207   4            }
 208   3            else if (key_value == 8 && key_state == 2) //如果s8短按
 209   3            {
 210   4              if (--screen < 2)
 211   4                screen = SCREEN_NUM - 1;
 212   4            }
 213   3            else if (key_value == 9 && key_state == 2) //如果s9短按
 214   3            {
 215   4              if (++screen > SCREEN_NUM - 1)
 216   4                screen = 2;
 217   4            }
 218   3            
 219   3            /* 显示输出 */
 220   3            dig = dig_all[screen]; //显示界面
 221   3            
 222   3            /* 界面1 显示当前温度 */
 223   3            
 224   3            /* 界面2 显示当前时间 */
 225   3            dig_all[2][0] = time_dec[0] / 10;
 226   3            dig_all[2][1] = time_dec[0] % 10;
 227   3            dig_all[2][3] = time_dec[1] / 10;
 228   3            dig_all[2][4] = time_dec[1] % 10;
 229   3            dig_all[2][6] = time_dec[2] / 10;
 230   3            dig_all[2][7] = time_dec[2] % 10;
 231   3                  
 232   3            /* 界面3 显示当前日期 */
 233   3            dig_all[3][0] = 2;
 234   3            dig_all[3][1] = 0;
 235   3            dig_all[3][2] = time_dec[5] / 10;
 236   3            dig_all[3][3] = time_dec[5] % 10;
 237   3            dig_all[3][4] = time_dec[3] / 10;
 238   3            dig_all[3][5] = time_dec[3] % 10;
 239   3            dig_all[3][6] = time_dec[4] / 10;
C51 COMPILER V9.60.0.0   TEST                                                              03/20/2023 21:07:26 PAGE 5   

 240   3            dig_all[3][7] = time_dec[4] % 10;
 241   3            
 242   3            /* 界面4 显示当前ne555输出频率 */
 243   3            dig_all[4][3] = ne555_out / 10000 % 10;
 244   3            dig_all[4][4] = ne555_out / 1000 % 10;
 245   3            dig_all[4][5] = ne555_out / 100 % 10;
 246   3            dig_all[4][6] = ne555_out / 10 % 10;
 247   3            dig_all[4][7] = ne555_out % 10;
 248   3            
 249   3            /* 界面5 显示ADC采样和DAC输出等级 */
 250   3            dig_all[5][0] = adc_level[1] / 0x10;
 251   3            dig_all[5][1] = adc_level[1] % 0x10;
 252   3            dig_all[5][3] = adc_level[3] / 0x10;
 253   3            dig_all[5][4] = adc_level[3] % 0x10;
 254   3            dig_all[5][6] = dac_level / 0x10;
 255   3            dig_all[5][7] = dac_level % 0x10;
 256   3          }
 257   2        }
 258   1      }
 259          
 260          /* 超声波测试 */
 261          void ultrasonic_test(void)
 262          {
 263   1        unsigned int distance = 0xFFFF;
 264   1        
 265   1        while(1)
 266   1        {
 267   2          if (Timer100ms_cnt >= 100)
 268   2          {
 269   3            Timer100ms_cnt = 0;
 270   3            
 271   3            /* 测距 */
 272   3            distance = read_distance();
 273   3            
 274   3            /* 控制继电器 */
 275   3            if (distance < 30)
 276   3              high_power_state |= 0x10;
 277   3            else
 278   3              high_power_state &= ~0x10;
 279   3            
 280   3            /* 距离显示 */
 281   3            dig[0] = distance / 10000;
 282   3            dig[1] = distance / 1000 % 10;
 283   3            dig[2] = distance / 100 % 10;
 284   3            dig[3] = distance / 10 % 10;
 285   3            dig[4] = distance % 10;
 286   3          }
 287   2        }
 288   1      }
 289          
 290          /* e2prom测试 */
 291          void e2prom_test(void)
 292          {
 293   1        uint16_t number;
 294   1        
 295   1        read_e2prom(0x14, (uint8_t*)&number, 2); //随便找了个地址测试，uint16_t是两个字节
 296   1        
 297   1        while(1)
 298   1        {
 299   2          /* 10ms执行一次按键扫描 */
 300   2          if (Timer10ms_cnt >= 10)
 301   2          {
C51 COMPILER V9.60.0.0   TEST                                                              03/20/2023 21:07:26 PAGE 6   

 302   3            Timer10ms_cnt = 0;
 303   3            
 304   3            key_pad_remain_scan_simple();
 305   3            
 306   3            if (key_value == 5 && key_state == 2) //增加数值
 307   3            {
 308   4              number++;
 309   4            }
 310   3            else if (key_value == 4 && key_state == 2) //减少数值
 311   3            {
 312   4              number--;
 313   4            }
 314   3            else if (key_value == 9 && key_state == 2) //保存数值，重新上电就能看到效果
 315   3            {
 316   4              write_e2prom(0x14, (uint8_t*)&number, 2);
 317   4              
 318   4              led_state = 0x01;
 319   4              Timer100ms_cnt = 0;
 320   4            }
 321   3            
 322   3            if (led_state && Timer100ms_cnt >= 100)
 323   3            {
 324   4              led_state = 0x00;
 325   4            }
 326   3            
 327   3            dig[0] = number / 10000 % 10;
 328   3            dig[1] = number / 1000 % 10;
 329   3            dig[2] = number / 100 % 10;
 330   3            dig[3] = number / 10 % 10;
 331   3            dig[4] = number % 10;
 332   3          }
 333   2        }
 334   1      }
 335          
 336          /* 温度测试 */
 337          void temperature_test(void)
 338          {
 339   1        while(1)
 340   1        {
 341   2          if (Timer100ms_cnt >= 100)
 342   2          {
 343   3            Timer100ms_cnt = 0;
 344   3            
 345   3            rd_temperature();
 346   3            
 347   3            if (temperature < 0) //负温度
 348   3            {
 349   4              dig[0] = 17;
 350   4              dig[1] = (-temperature) / 10000 % 10;
 351   4              dig[2] = (-temperature) / 1000 % 10;
 352   4              dig[3] = (-temperature) / 100 % 10 + 32;
 353   4              dig[4] = (-temperature) / 10 % 10;
 354   4              dig[5] = (-temperature) % 10;
 355   4            }
 356   3            else //非负温度
 357   3            {
 358   4              dig[0] = 16;
 359   4              dig[1] = temperature / 10000 % 10;
 360   4              dig[2] = temperature / 1000 % 10;
 361   4              dig[3] = temperature / 100 % 10 + 32;
 362   4              dig[4] = temperature / 10 % 10;
 363   4              dig[5] = temperature % 10;
C51 COMPILER V9.60.0.0   TEST                                                              03/20/2023 21:07:26 PAGE 7   

 364   4            }
 365   3          }
 366   2        }
 367   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1674    ----
   CONSTANT SIZE    =      6    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       8
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
