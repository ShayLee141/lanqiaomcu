C51 COMPILER V9.60.0.0   TEST                                                              04/06/2023 21:15:02 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE TEST
OBJECT MODULE PLACED IN .\Objects\test.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE test.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\others) DEBUG OBJECTEXTEND PRIN
                    -T(.\Listings\test.lst) TABS(2) OBJECT(.\Objects\test.obj)

line level    source

   1          #include "test.h"
   2          
   3          void Delay5ms()   //@12.000MHz
   4          {
   5   1        unsigned char i, j;
   6   1      
   7   1        i = 59;
   8   1        j = 90;
   9   1        do
  10   1        {
  11   2          while (--j);
  12   2        } while (--i);
  13   1      }
  14          
  15          void Delay100ms()   //@12.000MHz
  16          {
  17   1        unsigned char i, j;
  18   1      
  19   1        i = 195;
  20   1        j = 138;
  21   1        do
  22   1        {
  23   2          while (--j);
  24   2        } while (--i);
  25   1      }
  26          
  27          #if LED_PWM_TEST == 1
              /* led pwmæµ‹è¯•ï¼Œå‰å››ä¸ªç¯ä¼šç´¯åŠ è®¡æ•°ï¼Œåå››ä¸ªç¯ä¼šè¿è¡Œè·‘é©¬ç¯ï¼Œæ‰€æœ‰ç¯å‡ä¼šå‘ˆç°å‘¼
             -å¸ç¯çš„ç‰¹æ•ˆ */
              void test(void)
              {
                /* è¿™ä¸ªæ•°ç»„ä¿å­˜äº†æµæ°´ç¯çš„æ¯ä¸€å¸§çš„LEDçŠ¶æ€ï¼Œä»…åå››ä¸ªç¯ */
                uint8_t code led_state_all[6] = 
                { 0x80, 0x40, 0x20, 0x10, 0x20, 0x40, };
                
                int16_t add = 1; //ç”¨äºæ§åˆ¶ç´¯åŠ çš„æ–¹å‘
                uint8_t cnt = 0; //è®¡æ•°ï¼Œå¹¶æ˜¾ç¤ºåœ¨å‰å››ä¸ªç¯ä¸Š
                uint8_t led_state_cnt = 0; //ç”¨äºæµæ°´ç¯
                
                dig = dig_all[1]; //æ•°ç ç®¡åˆå§‹ç•Œé¢è®¾ç½®ä¸ºç•Œé¢1
                
                while(1)
                {
                  if (Timer500ms_cnt >= 500)
                  {
                    Timer500ms_cnt = 0;
                    
                    cnt++;
                    
                    if (++led_state_cnt >= 6) //ç”¨äºæµæ°´ç¯
                      led_state_cnt = 0;
                  }
                  
                  if (Timer100ms_cnt >= 100) //10msæ›´æ–°ä¸€æ¬¡pwmå ç©ºæ¯”å’Œledè¾“å‡ºçŠ¶æ€
C51 COMPILER V9.60.0.0   TEST                                                              04/06/2023 21:15:02 PAGE 2   

                  {
                    Timer100ms_cnt = 0;
                    
                    /* ledpwmå ç©ºæ¯”çš„æ§åˆ¶ */
                    led_pwm_duty += add;
                    if (led_pwm_duty >= 10)
                      add = -1;
                    if (led_pwm_duty <= 1)
                      add = 1;
                  
                    led_state = (cnt & 0x0F) | led_state_all[led_state_cnt];
                  }
                  
                  dig_all[1][0] = cnt / 0x10;
                  dig_all[1][1] = cnt % 0x10;
                }
              }
              
              #elif KEY_TEST == 1
              /* æŒ‰é”®æµ‹è¯• */
              void test(void)
              {
                uint8_t cnt = 127;
                
                dig = dig_all[2];
                
                while(1)
                {
                  /* 10msæ‰§è¡Œä¸€æ¬¡æŒ‰é”®æ‰«æ */
                  if (Timer10ms_cnt >= 10) //è¿™é‡Œå¯ä»¥ä¿®æ”¹æ¶ˆæŠ–æ—¶é—´ï¼Œå¦‚æœæƒ³çœ‹æ¸…æ¥šæ•°ç ç®¡å’ŒLEDä¸€é—ªè€Œè¿
             -‡çš„å†…å®¹ï¼Œä¸å¦¨æŠŠè¿™ä¸ªå€¼å¢å¤§åˆ°50æˆ–è€…æ›´å¤§ï¼Œä½†æ˜¯è¦è®°å¾—è°ƒå›æ¥å“¦
                  {
                    Timer10ms_cnt = 0;
                    
                    /* æŒ‰é”®æ‰«æ */
                    key_pad_scan();
              
                    /* åˆ¤æ–­æŒ‰é”® */
                    { /* æ— éå°±æ˜¯åˆ©ç”¨key_valueå’Œkey_stateä¸¤ä¸ªå˜é‡æ¥åˆ¤æ–­ */
                      if (key_value == 5 && key_state == 2) //s5çŸ­æŒ‰
                        led_state |= 0x01;
                      
                      else if (key_value == 5 && key_state == 100) //s5é•¿æŒ‰1ç§’
                        led_state |= 0x02;
                      
                      else if (key_value == 5 && key_state == 200) //s5é•¿æŒ‰2ç§’
                        led_state |= 0x04;
                      
                      else if (key_value == 5 && key_state > 250) //s5æ¾æ‰‹
                        led_state |= 0x08;
                      
                      else if (key_value == 9 && key_state >= 2) //s9æŒ‰ä½æ—¶
                      {
                        led_state |= 0x10;
                        
                        if (key_value == 9 && key_state == 255) //s9æŒ‰ä¸‹ä¸åˆ°1ç§’æ¾å¼€
                          led_state |= 0x20;
                        
                        else if (key_value == 9 && key_state == 254) //s9æŒ‰ä¸‹1ç§’è‡³2ç§’å†…æ¾å¼€
                          led_state |= 0x40;
                        
                        else if (key_value == 9 && key_state == 253) //s9æŒ‰ä¸‹2ç§’ä»¥ä¸Šå†æ¾å¼€
C51 COMPILER V9.60.0.0   TEST                                                              04/06/2023 21:15:02 PAGE 3   

                          led_state |= 0x80;
                      }
                      
                      else if (key_value == 13 && key_state == 2) //s13çŸ­æŒ‰ï¼Œæ§åˆ¶å˜é‡å¢å‡
                        cnt++;
                      
                      else if (key_value == 12 && key_state == 2) //s12çŸ­æŒ‰ï¼Œæ§åˆ¶å˜é‡å¢å‡
                        cnt--;
                      
                      else //é™¤æ­¤ä¹‹å¤–ï¼Œç†„ç­LED
                        led_state = 0x00;
                    }
              
                    /* æ•°ç ç®¡æ˜¾ç¤º */
                    {
                      /* é”®å€¼æ˜¾ç¤º */
                      dig_all[2][0] = key_value / 10;
                      dig_all[2][1] = key_value % 10;
                      
                      /* çŠ¶æ€æ˜¾ç¤º */
                      dig_all[2][3] = key_state / 100;
                      dig_all[2][4] = key_state / 10 % 10;
                      dig_all[2][5] = key_state % 10;
                      
                      /* å˜é‡æ˜¾ç¤º */
                      dig_all[2][7] = cnt % 10;
                    }
                  }
                }
              }
              
              #elif DISPLAY_TEST == 1
              /* æ˜¾ç¤ºæµ‹è¯• */
              void test(void)
              {
                uint8_t screen = 1; //å½“å‰ç•Œé¢
                uint8_t screen_bak = screen; //å¤‡ä»½å½“å‰ç•Œé¢ï¼Œä»¥ä¾¿é‡æ–°è¿”å›
                bit screen_hold = 0; //æ˜¾ç¤ºç•Œé¢5çš„æ ‡å¿—ä½
                bit screen_switch = 1; //æ˜¾ç¤ºå¼€å…³
                
                dig = dig_all[screen]; //é»˜è®¤ä¸ºç•Œé¢1
                
                while(1)
                {
                  /* 10msæ‰§è¡Œä¸€æ¬¡æŒ‰é”®æ‰«æ */
                  if (Timer10ms_cnt >= 10)
                  {
                    Timer10ms_cnt = 0;
                    
                    /* æŒ‰é”®æ‰«æ */
                    key_pad_scan();
                    
                    /* åˆ¤æ–­æŒ‰é”® */
                    if (key_value == 9 && key_state >= 2) //æŒ‰ä½s9æ—¶
                    {
                      if (!screen_hold && screen_switch) //ä»”ç»†ä½“ä¼šä¸€ä¸‹è¿™å¥ifå’Œä¸‹é¢é‚£å¥if
                      {
                        screen_hold = 1;
                        screen_bak = screen;
                        screen = 5;
                      }
                    }
C51 COMPILER V9.60.0.0   TEST                                                              04/06/2023 21:15:02 PAGE 4   

                    else
                    {
                      if (screen_hold) //ä»”ç»†ä½“ä¼šä¸€ä¸‹è¿™å¥ifå’Œä¸Šé¢é‚£å¥if
                      {
                        screen_hold = 0;
                        screen = screen_bak;
                      }
                      
                      if (key_value == 13 && key_state == 255) //æŒ‰s13æ¾æ‰‹æ—¶
                      {
                        if (screen < 4 && screen_switch) //é™åˆ¶åœ¨ç•Œé¢1åˆ°ç•Œé¢4ä¹‹é—´
                          screen++;
                      }
                      else if (key_value == 12 && key_state == 255) //æŒ‰s12æ¾æ‰‹æ—¶
                      {
                        if (screen > 1 && screen_switch)
                          screen--;
                      }
                      else if (key_value == 13 && key_state == 100) //é•¿æŒ‰1ç§’s13æ—¶
                      {
                        if (screen_switch) //å³å°†å…³é—­æ˜¾ç¤º
                        {
                          screen_bak = screen;
                          screen = 0;
                          screen_switch = 0;
                        }
                        else //å³å°†æ‰“å¼€æ˜¾ç¤º
                        {
                          screen = screen_bak;
                          screen_switch = 1;
                        }
                      }
                    }
                    
                    /* æ˜¾ç¤ºè¾“å‡º */
                    dig = dig_all[screen]; //æ˜¾ç¤ºç•Œé¢
                  }
                }
              }
              
              #elif ULTRASONIC_TEST == 1
              /* è¶…å£°æ³¢æµ‹è¯• */
              void test(void)
              {
                uint16_t distance_buf[3] = { 2, 2, 2 }; //ç”¨æ¥å­˜æ”¾æœ€è¿‘çš„3æ¬¡æµ‹è·ç»“æœï¼Œåˆå€¼ä¸è¦ç»™0
                uint16_t distance_out = 0; //å­˜æ”¾ç»è¿‡å‡å€¼æ»¤æ³¢åçš„ç»“æœ
                uint8_t p = 0;
                
                while(1)
                {
                  if (operate_timer_cnt >= 100)
                  {
                    operate_timer_cnt = 0;
                    
                    /* æµ‹è· */
                    read_distance();
                    
                    distance_buf[p] = distance;
                    if (++p >= 3)
                      p = 0;
                    distance_out = median_filter(distance_buf); //ä½¿ç”¨æ»¤æ³¢çš„èŒƒä¾‹ï¼Œä¸ä½¿ç”¨æ»¤æ³¢ä¹Ÿè¡Œçš„
                    
C51 COMPILER V9.60.0.0   TEST                                                              04/06/2023 21:15:02 PAGE 5   

                    /* æ§åˆ¶ç»§ç”µå™¨ */;
                    if (distance < 30)
                      high_power_state |= 0x10;
                    else
                      high_power_state &= ~0x10;
                    
                    /* è·ç¦»æ˜¾ç¤º */
                    dig[0] = distance_out / 10000;
                    dig[1] = distance_out / 1000 % 10;
                    dig[2] = distance_out / 100 % 10;
                    dig[3] = distance_out / 10 % 10;
                    dig[4] = distance_out % 10;
                    
                    /* ç”¨æ•°ç ç®¡æ˜¾ç¤ºultrasonic_flag */
                    led_state &= ~0x03;
                    led_state |= ultrasonic_flag;
                  }
                }
              }
              
              #elif RTC_TEST == 1
              /* å®æ—¶æ—¶é’Ÿæµ‹è¯• */
              void test(void)
              {
                uint8_t write_ds1302_flag = 0;
                write_ds1302();
                
                dig = dig_all[2]; //å“ªä¸ªç•Œé¢éƒ½ä¸€æ ·
                
                dig_all[2][2] = 17; //åˆ†éš”ç¬¦â€œ-â€
                dig_all[2][5] = 17; //åˆ†éš”ç¬¦â€œ-â€
                
                loop: //è¿™é‡Œå±•ç¤ºå¦å¤–ä¸€ç§å¾ªç¯çš„å†™æ³•ï¼Œå’Œwhile(1)æ˜¯ä¸€æ ·çš„
              
                if (Timer10ms_cnt)
                {
                  Timer10ms_cnt = 0;
                  
                  key_pad_scan();
                  
                  if (key_value == 9 && key_state == 2) //s9æš‚åœæˆ–å¯åŠ¨æ—¶é—´
                  {
                    write_ds1302_flag++;
                  }
                }
                
                if (operate_timer_cnt > 50)
                {
                  operate_timer_cnt = 0;
                  
                  if (write_ds1302_flag >= 2)
                  {
                    write_ds1302();
                    write_ds1302_flag = 0;
                  }
                  else if (write_ds1302_flag == 0)
                    read_ds1302();
                  else //å¦‚æœwrite_ds1302_flag == 1ï¼Œè¡¨ç¤ºæ—¶é—´æš‚åœ
                    ;
                }
                
                dig_all[2][0] = time_10[0] / 10;
C51 COMPILER V9.60.0.0   TEST                                                              04/06/2023 21:15:02 PAGE 6   

                dig_all[2][1] = time_10[0] % 10;
                
                dig_all[2][3] = time_10[1] / 10;
                dig_all[2][4] = time_10[1] % 10;
                
                dig_all[2][6] = time_10[2] / 10;
                dig_all[2][7] = time_10[2] % 10;
                
                if (write_ds1302_flag) //æ—¶åœçš„æ—¶å€™ç‚¹äº®led
                  led_state |= 0x80;
                else
                  led_state &= ~0x80;
                
                goto loop; //ç¨‹åºè·‘åˆ°è¿™é‡Œä¼šè·³è½¬åˆ°ä¸Šé¢çš„loopæ ‡å¿—é‡æ–°å¼€å§‹è¿è¡Œ
              }
              
              #elif E2PROM_TEST == 1
              /* e2promæµ‹è¯• */
              void test(void) æœªå®Œå·¥
              {
                uint8_t Data_e[16] = { 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, };
                uint8_t Data0[16] = { 2, 0, 2, 3, 0, 3, 2, 6, 1, 2, 3, 4, 5, 6, 7, 8, };
                uint8_t Data1[18] = { 0, };
                uint8_t operate = 0;
                uint8_t addr = 15;
                uint8_t addr_flag = 0;
                
                while(1);
                {
                  if (Timer10ms_cnt >= 10)
                  {
                    Timer10ms_cnt = 0;
                    
                    key_pad_scan();
                    
                    if (operate_timer_cnt >= 100)
                    {
                      operate_timer_cnt = 0;
                      
                      switch (operate++)
                      {
                        default:
                          operate = 1;
                        case 0:
                          e2prom_read(addr, Data1, 8);
                          break;
                        
                        case 1:
                          break;
                        
                        case 10:
                          e2prom_write(addr, Data_e, 8);
                          break;
                        
                        case 11:
                          e2prom_write(addr + 8, Data_e + 8, 8);
                          break;
                      }
                    }
                    
                    if (key_value == 9 && key_state == 2)
                    {
C51 COMPILER V9.60.0.0   TEST                                                              04/06/2023 21:15:02 PAGE 7   

                      operate = 10;
                    }
                    else if (key_value == 13 && key_state == 2)
                    {
                      if (addr_flag == 0)
                        addr += 8;
                      else
                        addr -= 8;
                      addr_flag = !addr_flag;
                    }
                    
                    dig[0] = Data1[0];
                    dig[1] = Data1[1];
                    dig[2] = Data1[2];
                    dig[3] = Data1[3];
                    dig[4] = Data1[4];
                    dig[5] = Data1[5];
                    dig[6] = Data1[6];
                    dig[7] = Data1[7];
                  }
                }
              }
              
              #elif ADC_DAC_TEST == 1
              /* adc_dacæµ‹è¯• */
              void test(void)
              {
                uint8_t operate_flag = 0;
                uint8_t channel = 0;
                
                dig[0] = 0x0C;
                
                dac_level = 127;
                dac_out();
                Delay5ms();
                
                loop:
                if (Timer10ms_cnt >= 10)
                {
                  Timer10ms_cnt = 0;
                  
                  key_pad_scan();
                  
                  if (operate_timer_cnt >= 20)
                  {
                    operate_timer_cnt = 0;
                    
                    switch (operate_flag++)
                    {
                      default:
                        operate_flag = 1;
                      case 0:
                        adc_read();
                        break;
                      
                      case 10:
                        dac_out();
                        break;
                      
                      case 12:
                        dac_stop();
                        break;
C51 COMPILER V9.60.0.0   TEST                                                              04/06/2023 21:15:02 PAGE 8   

                    }
                  }
                  
                  if (key_value == 9 && key_state == 2)
                  {
                    if (control_byte & 0x40)
                      operate_flag = 12;
                    else
                      operate_flag = 10;
                  }
                  else if (key_value == 13 && key_state == 2)
                  {
                    if (++channel >= 4)
                      channel = 0;
                  }
                  
                  dig[1] = channel;
                  dig[3] = adc_level[channel] / 0x10;
                  dig[4] = adc_level[channel] % 0x10;
                  if (control_byte & 0x40)
                  {
                    dig[6] = dac_level / 0x10;
                    dig[7] = dac_level % 0x10;
                    led_state |= 0x80;
                  }
                  else
                  {
                    dig[6] = 17;
                    dig[7] = 17;
                    led_state &= ~0x80;
                  }
                }
                goto loop;
              }
              
              #elif TEMP_TEST == 1
 461          /* æ¸©åº¦æµ‹è¯• */
 462          void test(void)
 463          {
 464   1        read_temp();
 465   1        Delay100ms();
 466   1        
 467   1        while (1)
 468   1        {
 469   2          if (operate_timer_cnt >= 20)
 470   2          {
 471   3            operate_timer_cnt = 0;
 472   3            
 473   3            read_temp();
 474   3          }
 475   2          
 476   2          dig[0] = temperature / 1000;
 477   2          dig[1] = temperature / 100 % 10 + 32;
 478   2          dig[2] = temperature / 10 % 10;
 479   2          dig[3] = temperature % 10;
 480   2        }
 481   1      }
 482          
 483          #elif UART_TEST == 1
              /* ä¸²å£æµ‹è¯• */
              void test(void)
              {
C51 COMPILER V9.60.0.0   TEST                                                              04/06/2023 21:15:02 PAGE 9   

                dig_switch = 0x00;
                
                dig[1] = 5;
                dig[2] = 25;
                dig[3] = 0xC;
                dig[4] = 0xC;
                dig[5] = 0xE;
                dig[6] = 5;
                dig[7] = 5;
                
                SendString("echo uart\r\n");
                
                while (1)
                {
                  if (Timer10ms_cnt >= 10)
                  {
                    Timer10ms_cnt = 0;
                    key_pad_scan(); //çŸ©é˜µé”®ç›˜å¹¶ä¸ä¼šå½±å“ä¸²å£æ”¶å‘
                  }
                  
                  if (cmd)
                  {
                    Timern_cnt = 0;
                  }
                  else if (Timern_cnt >= 5000)
                  {
                    Timern_cnt = 0;
                    SendString("input 'A' or 'B' or 'C':\r\n");
                  }
                  
                  if (cmd & 0x01)
                  {
                    led_state ^= 0x80;
                    cmd &= ~0x01;
                  }
                  if (cmd & 0x02)
                  {
                    dig_switch = ~dig_switch;
                    cmd &= ~0x02;
                  }
                  if (cmd & 0x04)
                  {
                    high_power_state ^= 0x10;
                    cmd &= ~0x04;
                  }
                }
              }
              
              #elif CHIPS_TEST == 1
              /* æ‰€æœ‰èŠ¯ç‰‡ç»¼åˆæµ‹è¯• */
              void test(void)
              {
                uint8_t mode = 1;
                uint8_t operate_flag = 0;
                
                read_temp();
                write_ds1302();
                dac_out();
                Delay5ms();
                adc_read();
                
                dig_all[1][2] = dig_all[1][5] = 17; //åˆ†éš”ç¬¦â€œ-â€
C51 COMPILER V9.60.0.0   TEST                                                              04/06/2023 21:15:02 PAGE 10  

                
                loop:
                
                if (Timer10ms_cnt >= 10)
                {
                  Timer10ms_cnt = 0;
                  
                  /* æŒ‰é”®æ‰«æ */
                  key_pad_scan();
                  
                  /* å„ç§æ—¶åºæ“ä½œ */
                  if (operate_timer_cnt >= 20)
                  {
                    operate_timer_cnt = 0;
                    
                    switch (operate_flag++)
                    {
                      default:
                        operate_flag = 1;
                      case 0:
                        read_ds1302();
                        break;
                      case 1:
                        adc_read();
                        break;
                      case 2:
                        read_temp();
                        break;
                      case 3:
                        read_distance();
                        break;
                    }
                  }
                  
                  /* æŒ‰é”®åŠŸèƒ½ */
                  if (key_value == 13 && key_state == 2)
                  {
                    if (++mode >= SCREEN_NUM)
                      mode = 1;
                  }
                  else if (key_value == 12 && key_state == 2)
                  {
                    if (--mode <= 1)
                      mode = SCREEN_NUM - 1;
                  }
                  
                  /* ledæ˜¾ç¤ºå½“å‰æ¨¡å¼ */
                  led_state = 0x01 << (mode - 1);
                  
                  /* æ•°ç ç®¡ç•Œé¢é€‰æ‹© */
                  dig = dig_all[mode];
                  
                  /* ç•Œé¢1 æ—¶é’Ÿæ˜¾ç¤º */
                  dig_all[1][0] = time_10[0] / 10;
                  dig_all[1][1] = time_10[0] % 10;
                  
                  dig_all[1][3] = time_10[1] / 10;
                  dig_all[1][4] = time_10[1] % 10;
                  
                  dig_all[1][6] = time_10[2] / 10;
                  dig_all[1][7] = time_10[2] % 10;
                  
C51 COMPILER V9.60.0.0   TEST                                                              04/06/2023 21:15:02 PAGE 11  

                  /* ç•Œé¢2 ADCé€šé“0ã€1 */
                  dig_all[2][0] = adc_level[0] / 100;
                  dig_all[2][1] = adc_level[0] / 10 % 10;
                  dig_all[2][2] = adc_level[0] % 10;
                  
                  dig_all[2][5] = adc_level[1] / 100;
                  dig_all[2][6] = adc_level[1] / 10 % 10;
                  dig_all[2][7] = adc_level[1] % 10;
                  
                  /* ç•Œé¢3 ADCé€šé“2ã€3 */
                  dig_all[3][0] = adc_level[2] / 100;
                  dig_all[3][1] = adc_level[2] / 10 % 10;
                  dig_all[3][2] = adc_level[2] % 10;
                  
                  dig_all[3][5] = adc_level[3] / 100;
                  dig_all[3][6] = adc_level[3] / 10 % 10;
                  dig_all[3][7] = adc_level[3] % 10;
                  
                  /* ç•Œé¢4 DACã€è¶…å£°æ³¢æµ‹è· */
                  dig_all[4][0] = dac_level / 100;
                  dig_all[4][1] = dac_level / 10 % 10;
                  dig_all[4][2] = dac_level % 10;
                  
                  dig_all[4][5] = distance / 100;
                  dig_all[4][6] = distance / 10 % 10;
                  dig_all[4][7] = distance % 10;
                  
                  /* ç•Œé¢5 ne555é¢‘ç‡ */
                  dig_all[5][3] = ne555_out / 1000;
                  dig_all[5][4] = ne555_out / 100 % 10;
                  dig_all[5][5] = ne555_out / 10 % 10;
                  dig_all[5][6] = ne555_out % 10;
                  dig_all[5][7] = 0;
                  
                  /* ç•Œé¢6 æ¸©åº¦æ˜¾ç¤º */
                  dig_all[6][4] = temperature / 10000;
                  dig_all[6][5] = temperature / 1000 % 10;
                  dig_all[6][6] = temperature / 100 % 10 + 32;
                  dig_all[6][7] = temperature % 10;
                }
                
                goto loop;
              }
              
              #else
              void test(void) //è¿™ä¸ªåªæ˜¯ä¸ºäº†é˜²æ­¢è­¦å‘Š
              {
                ;
              }
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    140    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
