C51 COMPILER V9.60.0.0   IIC                                                               03/20/2023 10:31:12 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE IIC
OBJECT MODULE PLACED IN .\Objects\iic.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE others\iic.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\others) DEBUG OBJECTEXTEN
                    -D PRINT(.\Listings\iic.lst) TABS(2) OBJECT(.\Objects\iic.obj)

line level    source

   1          #include "iic.h"
   2          
   3          sbit SDA = P2^1; //这两句是从h文件移过来的
   4          sbit SCL = P2^0;
   5          
   6          #define DELAY_TIME 5
   7          
   8          //I2C总线内部延时函数
   9          void IIC_Delay(unsigned char i)
  10          {
  11   1          do{_nop_();}
  12   1          while(i--);        
  13   1      }
  14          
  15          //I2C总线启动信号
  16          void IIC_Start(void)
  17          {
  18   1          SDA = 1;
  19   1          SCL = 1;
  20   1          IIC_Delay(DELAY_TIME);
  21   1          SDA = 0;
  22   1          IIC_Delay(DELAY_TIME);
  23   1          SCL = 0;  
  24   1      }
  25          
  26          //I2C总线停止信号
  27          void IIC_Stop(void)
  28          {
  29   1          SDA = 0;
  30   1          SCL = 1;
  31   1          IIC_Delay(DELAY_TIME);
  32   1          SDA = 1;
  33   1          IIC_Delay(DELAY_TIME);
  34   1      }
  35          
  36          //发送应答或非应答信号
  37          void IIC_SendAck(bit ackbit)
  38          {
  39   1          SCL = 0;
  40   1          SDA = ackbit;           
  41   1          IIC_Delay(DELAY_TIME);
  42   1          SCL = 1;
  43   1          IIC_Delay(DELAY_TIME);
  44   1          SCL = 0; 
  45   1          SDA = 1;
  46   1          IIC_Delay(DELAY_TIME);
  47   1      }
  48          
  49          //等待应答
  50          bit IIC_WaitAck(void)
  51          {
  52   1          bit ackbit;
  53   1        
  54   1          SCL  = 1;
C51 COMPILER V9.60.0.0   IIC                                                               03/20/2023 10:31:12 PAGE 2   

  55   1          IIC_Delay(DELAY_TIME);
  56   1          ackbit = SDA;
  57   1          SCL = 0;
  58   1          IIC_Delay(DELAY_TIME);
  59   1          return ackbit;
  60   1      }
  61          
  62          //I2C总线发送一个字节数据
  63          void IIC_SendByte(unsigned char byt)
  64          {
  65   1          unsigned char i;
  66   1      
  67   1          for(i=0; i<8; i++)
  68   1          {
  69   2              SCL  = 0;
  70   2              IIC_Delay(DELAY_TIME);
  71   2              if(byt & 0x80) SDA  = 1;
  72   2              else SDA  = 0;
  73   2              IIC_Delay(DELAY_TIME);
  74   2              SCL = 1;
  75   2              byt <<= 1;
  76   2              IIC_Delay(DELAY_TIME);
  77   2          }
  78   1          SCL  = 0;  
  79   1      }
  80          
  81          //I2C总线接收一个字节数据
  82          unsigned char IIC_RecByte(void)
  83          {
  84   1          unsigned char i, da;
  85   1          for(i=0; i<8; i++)
  86   1          {   
  87   2            SCL = 1;
  88   2        IIC_Delay(DELAY_TIME);
  89   2        da <<= 1;
  90   2        if(SDA) da |= 1;
  91   2        SCL = 0;
  92   2        IIC_Delay(DELAY_TIME);
  93   2          }
  94   1          return da;    
  95   1      }
  96          
  97          /**** ↑↑↑ 以上代码均未修改，下面是自己加的 ↓↓↓ ********/
  98          
  99          /****************** ↓↓↓ PCF8591 ↓↓↓ ******************/
 100          uint8_t dac_level = 0; //当前dac输出等级
 101          uint8_t control_byte = 0x04;
 102          //有关这个变量的设置，请见PCF0591的数据手册，CONTROL BYTE
 103          
 104          /* dac输出 */
 105          void write_dac(void)
 106          {
 107   1        control_byte |= 0x40;
 108   1        
 109   1        IIC_Start();
 110   1        IIC_SendByte(0x90);
 111   1        IIC_WaitAck();
 112   1        IIC_SendByte(control_byte);
 113   1        IIC_WaitAck();
 114   1        IIC_SendByte(dac_level);
 115   1        IIC_Stop();
 116   1      }
C51 COMPILER V9.60.0.0   IIC                                                               03/20/2023 10:31:12 PAGE 3   

 117          
 118          /* 停止dac输出 */
 119          void stop_dac(void)
 120          {
 121   1        control_byte &= ~0x40;
 122   1        
 123   1        IIC_Start();
 124   1        IIC_SendByte(0x90);
 125   1        IIC_WaitAck();
 126   1        IIC_SendByte(control_byte);
 127   1        IIC_Stop();
 128   1      }
 129          
 130          uint8_t adc_level[4] = { 0 }; //对应4个adc通道
 131          /* adc采集 */
 132          void read_adc(void)
 133          {
 134   1        IIC_Start();
 135   1        IIC_SendByte(0x90);
 136   1        IIC_WaitAck();
 137   1        IIC_SendByte(control_byte);
 138   1        IIC_WaitAck();
 139   1        
 140   1        IIC_Start();
 141   1        IIC_SendByte(0x91);
 142   1        IIC_WaitAck();
 143   1        
 144   1        IIC_RecByte(); //预读
 145   1        IIC_SendAck(0);
 146   1        //ADC每一次读数都是上一次采样的值，
 147   1        //并且因为我们开启了通道通道数自增的读法，
 148   1        //会导致返回的值不是我们想要的通道，
 149   1        //所以这里的预读仅为了让芯片采样，而不保留读数
 150   1        
 151   1        adc_level[0] = IIC_RecByte();
 152   1        IIC_SendAck(0);
 153   1        adc_level[1] = IIC_RecByte();
 154   1        IIC_SendAck(0);
 155   1        adc_level[2] = IIC_RecByte();
 156   1        IIC_SendAck(0);
 157   1        adc_level[3] = IIC_RecByte();
 158   1        IIC_Stop(); //最后一次读可以直接结束，无需发应答信号
 159   1      }
 160          /****************** ↑↑↑ PCF8591 ↑↑↑ ******************/
 161          
 162          /****************** ↓↓↓ AT24C02 ↓↓↓ ******************/
 163          /* 单字节写入（新手掌握这个即可，省赛多数考的单字节操作）
 164             addr： 目标地址
 165             Data： 写入数据的指针
 166             （其实Data直接用变量，不用指针也行，只是为了和后面的统一） */
 167          void write_e2prom_single_byte(uint8_t addr, uint8_t *Data)
 168          {
 169   1        IIC_Start();
 170   1        IIC_SendByte(0xA0);
 171   1        IIC_WaitAck();
 172   1        
 173   1        IIC_SendByte(addr); //确定目标地址
 174   1        IIC_WaitAck();
 175   1        
 176   1        IIC_SendByte(*Data); //写入数据
 177   1        IIC_WaitAck();
 178   1        
C51 COMPILER V9.60.0.0   IIC                                                               03/20/2023 10:31:12 PAGE 4   

 179   1        IIC_Stop();
 180   1      }
 181          
 182          /* 单字节读取（新手掌握这个即可，省赛多数考的单字节操作）
 183             addr： 目标地址
 184             Data：读取数据的指针
 185             （这个Data只能用指针，不能改成变量） */
 186          void read_e2prom_single_byte(uint8_t addr, uint8_t *Data)
 187          {
 188   1        IIC_Start();
 189   1        IIC_SendByte(0xA0);
 190   1        IIC_WaitAck();
 191   1        
 192   1        IIC_SendByte(addr); //确定目标地址
 193   1        IIC_WaitAck();
 194   1        
 195   1        IIC_Start();
 196   1        IIC_SendByte(0xA1);
 197   1        IIC_WaitAck();
 198   1        
 199   1        *Data = IIC_RecByte(); //读取数据
 200   1        
 201   1        IIC_Stop();
 202   1      }
 203          
 204          /* 多字节写入（学有余力的直接掌握这个，可以取代单字节写入，其实也是没什么难度的，就是循环那里要理解一下）
 205             addr： 目标地址
 206             Data： 写入数据的指针
 207             len：  写入字节数 */
 208          void write_e2prom(uint8_t addr, uint8_t *Data, uint8_t len)
 209          {
 210   1        IIC_Start();
 211   1        IIC_SendByte(0xA0);
 212   1        IIC_WaitAck();
 213   1        
 214   1        IIC_SendByte(addr); //确定目标地址
 215   1        IIC_WaitAck();
 216   1        
 217   1        while(len--)
 218   1        {
 219   2          IIC_SendByte(*Data);
 220   2          IIC_WaitAck();
 221   2          Data++; //指针自加，所指向的地址则会跳到下一个字节
 222   2        }
 223   1        
 224   1        IIC_Stop();
 225   1      }
 226          
 227          /* 多字节读取（学有余力的直接掌握这个，可以取代单字节读取，其实也是没什么难度的，就是循环那里要理解一下）
 228             addr： 目标地址
 229             Data： 读取数据的指针
 230             len：  读取字节数 */
 231          void read_e2prom(uint8_t addr, uint8_t *Data, uint8_t len)
 232          {
 233   1        IIC_Start();
 234   1        IIC_SendByte(0xA0);
 235   1        IIC_WaitAck();
 236   1        
 237   1        IIC_SendByte(addr); //确定目标地址
 238   1        IIC_WaitAck();
 239   1        
 240   1        IIC_Start();
C51 COMPILER V9.60.0.0   IIC                                                               03/20/2023 10:31:12 PAGE 5   

 241   1        IIC_SendByte(0xA1);
 242   1        IIC_WaitAck();
 243   1        
 244   1        loop: //和下面的goto结合做成循环，思来想去还是goto做这个循环最简单
 245   1        *Data = IIC_RecByte(); //读取数据
 246   1        if (--len) //最后一次接收不需要发应答可以直接stop
 247   1        {
 248   2          IIC_SendAck(0);
 249   2          Data++;
 250   2          goto loop;
 251   2        }
 252   1        
 253   1        IIC_Stop();
 254   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    452    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6      12
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
