C51 COMPILER V9.60.0.0   KEY                                                               04/06/2023 17:23:19 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE KEY
OBJECT MODULE PLACED IN .\Objects\key.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE key.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\others) DEBUG OBJECTEXTEND PRINT
                    -(.\Listings\key.lst) TABS(2) OBJECT(.\Objects\key.obj)

line level    source

   1          #include "key.h"
   2          
   3          /* 下面列出的所有按键函数
   4             均使用这两个变量作为输出，
   5             主函数里只需要判断这两个变量，
   6             即可获取按键状态信息 */
   7          uint8_t key_value = 0; //取值范围4 - 19
   8          uint8_t key_state = 0;
   9          /* key_state表示按键当前状态
  10             0：表示未按下
  11             1：按键正在消抖处理
  12             2 - 250：表示消抖以后按下的时间，单位是10ms
  13                      本模板只计时到2.5秒，需要的可以延长
  14                      注意要改成uint16_t类型
  15             253：当前按键从按下到松开的时间大于2秒
  16             254：当前按键从按下到松开的时间在1秒到2秒之间
  17             255：当前按键从按下到松开的时间不到1秒 */
  18          
  19          /* 键值查询表 */
  20          uint8_t code key_pad_value_all[4][4] = 
  21          { //常用于矩阵按键
  22            {7, 11, 15, 19, },
  23            {6, 10, 14, 18, },
  24            {5, 9, 13, 17, },
  25            {4, 8, 12, 16, },
  26          };
  27          /* 一般都是10ms左右调用一次，
  28             10ms为消抖时间，可以根据需要更改 */
  29          /* 矩阵按键 */
  30          void key_pad_scan()
  31          {
  32   1        uint8_t row = 255, column = 255; //行号与列号，255是默认值，即无效值
  33   1        
  34   1        /* 操作IO口，这里按每个位来操作的，实际上可以统一赋值 */
  35   1      #ifndef USE_UART
                P30 = 1; //第1行
                P31 = 1; //第2行
              #endif //USE_UART
  39   1        P32 = 1; //第3行
  40   1        P33 = 1; //第4行
  41   1        
  42   1        P44 = 0; //第1列
  43   1        P42 = 0; //第2列
  44   1        P35 = 0; //第3列
  45   1      #ifndef USE_NE555
  46   1        P34 = 0; //第4列
  47   1      #endif //USE_NE555
  48   1        
  49   1        if (~P3 & 0x0F) //如果有按键按下；这里可以翻译为P3取反后屏蔽掉高四位，有按键
             -下则这个结果就不为零，和前面独立按键一致的
  50   1        {
  51   2          /* 行判断 */
  52   2          if (!P33) //第4行
  53   2            row = 3;
C51 COMPILER V9.60.0.0   KEY                                                               04/06/2023 17:23:19 PAGE 2   

  54   2          else if (!P32) //第3行
  55   2            row = 2;
  56   2      #ifndef USE_UART
                  else if (!P31) //第2行
                    row = 1;
                  else if (!P30) //第1行
                    row = 0;
              #endif //USE_UART
  62   2          else //如果使误读则退出函数
  63   2            return ;
  64   2          
  65   2          /* 操作IO口 */
  66   2      #ifndef USE_UART
                  P30 = 0; //第1行
                  P31 = 0; //第2行
              #endif //USE_UART
  70   2          P32 = 0; //第3行
  71   2          P33 = 0; //第4行
  72   2          
  73   2          P44 = 1; //第1列
  74   2          P42 = 1; //第2列
  75   2          P35 = 1; //第3列
  76   2          P34 = 1; //第4列
  77   2          
  78   2          /* 列判断 */
  79   2          if (!P44) //第1列
  80   2            column = 0;
  81   2          else if (!P42) //第2列
  82   2            column = 1;
  83   2          else if (!P35) //第3列
  84   2            column = 2;
  85   2      #ifndef USE_NE555
  86   2          else if (!P34) //第4列
  87   2            column = 3;
  88   2      #endif //USE_NE555
  89   2          else //如果使误读则退出函数
  90   2            return ;
  91   2          
  92   2          /* 键值判断 */
  93   2          if (row != 255 && column != 255) //如果按键有效
  94   2          {
  95   3            key_value = key_pad_value_all[row][column];
  96   3          }
  97   2          
  98   2          /* 按键计时 */
  99   2          if (key_state < 250)
 100   2            key_state++;
 101   2        }
 102   1        else
 103   1        {
 104   2      #ifdef KEY_RELEASE
 105   2          if (key_value && key_state <= 250) //如果按键刚松开
 106   2          {
 107   3            if (key_state < 100) //若按下到松手时间没有超过1秒
 108   3              key_state = 255;
 109   3            else if (key_state < 200) //若按下到松手时间超过1秒而没超过2秒
 110   3              key_state = 254;
 111   3            else //若按下到松手时间超过2秒
 112   3              key_state = 253;
 113   3          }
 114   2          else //按键完全松开
 115   2      #endif //KEY_RELEASE
C51 COMPILER V9.60.0.0   KEY                                                               04/06/2023 17:23:19 PAGE 3   

 116   2          {
 117   3            key_value = 0;
 118   3            key_state = 0;
 119   3          }
 120   2        }
 121   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    179    ----
   CONSTANT SIZE    =     16    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
