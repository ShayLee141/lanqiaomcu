C51 COMPILER V9.60.0.0   ULTRASONIC                                                        03/29/2023 19:45:29 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE ULTRASONIC
OBJECT MODULE PLACED IN .\Objects\ultrasonic.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ultrasonic.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\others) DEBUG OBJECTEXTEN
                    -D PRINT(.\Listings\ultrasonic.lst) TABS(2) OBJECT(.\Objects\ultrasonic.obj)

line level    source

   1          #include "ultrasonic.h"
   2          
   3          bit ultrasonic_busy = 0; //忙标志
   4          bit ultrasonic_outrange = 0; //超量程标志
   5          
   6          /* 如果你发现测距的量程很短，那你应该看看
   7             下载的时候IRC频率有没有调成12.000MHz，
   8             而不是来质疑我的代码 (>w<) */
   9          void Delay13us()    //@12.000MHz
  10          {
  11   1        unsigned char i;
  12   1      
  13   1        _nop_();
  14   1        _nop_();
  15   1        i = 36;
  16   1        while (--i);
  17   1      }
  18          
  19          void TimerPCAInit()
  20          {
  21   1        CCON = 0; //初始化PCA控制寄存器
  22   1                  //PCA定时器停止
  23   1                  //清除CF标志
  24   1                  //清除模块中断标志
  25   1        CMOD = 0x01;    //设置PCA时钟源 1MHz
  26   1                        //开启PCA定时器溢出中断
  27   1        CCAPM0 = 0x11;  //PCA模块0为下降沿触发
  28   1                        //利用脉冲捕获来模拟P11下降沿外部中断
  29   1      }
  30          
  31          /* P11，即超声波RX，一旦出现下降沿，
  32             则说明已经收到返回的超声波，进入此中断 */
  33          void TimerPCAIsr() interrupt 7
  34          {
  35   1        CR = 0; //优先结束计时
  36   1        
  37   1        /* 清除标志位，必须把标志位清除，不然会卡死 */
  38   1        if (CCF0)
  39   1          CCF0 = 0;
  40   1        if (CF)
  41   1        {
  42   2          CF = 0;
  43   2          ultrasonic_outrange = 1;
  44   2        }
  45   1        
  46   1        ultrasonic_busy = 0;
  47   1      }
  48          
  49          uint16_t distance = 0; //这个初值必须为0
  50          /* 超声波测距函数
  51             每一次调用会先对上一次测距的数值进行换算，
  52             再发送一组新的超声波，随后返回换算的值，
  53             若调用的时候上一次测距未完成，则会直接跳过，
  54             所以理论上可以连续调用不用间隔时间，
C51 COMPILER V9.60.0.0   ULTRASONIC                                                        03/29/2023 19:45:29 PAGE 2   

  55             出于安全和全局考虑，还是建议读取间隔至少为50ms，
  56             可根据需要更改（50ms效果已经很好了，太快没啥用哈哈） */
  57          uint16_t read_distance()
  58          {
  59   1        /* 实际上distance不可能为0，所以用0作为初值，
  60   1           可以识别是否为开机第一次测距离 */
  61   1        
  62   1        if (!ultrasonic_busy) //如果正处于发送阶段则直接跳过
  63   1        {
  64   2          /* 距离换算 */
  65   2          if (distance)
  66   2          /* 如果是开机第一次测距，则会跳过if里的内容，
  67   2             执行后面else里的distance = 1，确保第一次测距不会
  68   2             进行距离换算，进而不会得到错误的结果，
  69   2             但其实只会影响第一次测距 */
  70   2          {
  71   3            if (ultrasonic_outrange) //如果计数溢出了表面超出量程了
  72   3            {
  73   4              ultrasonic_outrange = 0;
  74   4              distance = DISTANCE_OUTRANG;
  75   4            }
  76   3            else //没有超量程则要进行
  77   3            {
  78   4              distance = CCAP0H;
  79   4              distance <<= 8;
  80   4              distance |= CCAP0L;
  81   4              distance -= 0x8D1C; //减掉定时器初值，减去初值原因在设置初值的地方有注解
  82   4              distance = (float)distance * 0.017;
  83   4            }
  84   3          }
  85   2          else
  86   2            distance = 1;
  87   2          
  88   2          /* 启动定时器 */
  89   2          CL = 0x1C;    //设置定时初始值
  90   2          CH = 0x8D;    //设置定时初始值
  91   2          /* 经过测试，板子能测的最长距离是4米（至少我这块板子是这样），
  92   2             而定时器的理论量程远超4米，所以设置初值的意义在于缩短量程
  93   2             （大概缩减到5米），以此来减少不必要的测量时间，
  94   2             所以超声波传播的时间就是终值减初值 */
  95   2          CF = 0;   //清除CF标志
  96   2          EA = 0; //我们有个定时器是100微秒的，对这个一定会有影响，所以要先关闭中断
  97   2          
  98   2          /* 启动超声波发送 */
  99   2          CR = 1;   //定时器开始计时
 100   2          P10 = 1; Delay13us(); P10 = 0; Delay13us(); //高电平在前低电平在后
 101   2          P10 = 1; Delay13us(); P10 = 0; Delay13us();
 102   2          P10 = 1; Delay13us(); P10 = 0; Delay13us();
 103   2          P10 = 1; Delay13us(); P10 = 0; Delay13us();
 104   2          P10 = 1; Delay13us(); P10 = 0; Delay13us();
 105   2          P10 = 1; Delay13us(); P10 = 0; Delay13us();
 106   2          P10 = 1; Delay13us(); P10 = 0; Delay13us();
 107   2          P10 = 1; Delay13us(); P10 = 0;
 108   2          
 109   2          EA = 1; //重新打开中断
 110   2          
 111   2          ultrasonic_busy = 1; //只有中断7才能重新置零
 112   2        }
 113   1        
 114   1        return distance;
 115   1      }

C51 COMPILER V9.60.0.0   ULTRASONIC                                                        03/29/2023 19:45:29 PAGE 3   


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    186    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
